I need to update my promptly swift app so it can also use the openwebui api specified below.  The app source code is included as a json file at the end.

---
sidebar_position: 400
title: "🔗 API Endpoints"
---

This guide provides essential information on how to interact with the API endpoints effectively to achieve seamless integration and automation using our models. Please note that this is an experimental setup and may undergo future updates for enhancement.

## Authentication

To ensure secure access to the API, authentication is required 🛡️. You can authenticate your API requests using the Bearer Token mechanism. Obtain your API key from **Settings > Account** in the Open WebUI, or alternatively, use a JWT (JSON Web Token) for authentication.

## Notable API Endpoints

### 📜 Retrieve All Models

- **Endpoint**: `GET /api/models`
- **Description**: Fetches all models created or added via Open WebUI.
- **Example**:

  ```bash
  curl -H "Authorization: Bearer YOUR_API_KEY" http://localhost:3000/api/models
  ```

### 💬 Chat Completions

- **Endpoint**: `POST /api/chat/completions`
- **Description**: Serves as an OpenAI API compatible chat completion endpoint for models on Open WebUI including Ollama models, OpenAI models, and Open WebUI Function models.
- **Example**:

  ```bash
  curl -X POST http://localhost:3000/api/chat/completions \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
        "model": "llama3.1",
        "messages": [
          {
            "role": "user",
            "content": "Why is the sky blue?"
          }
        ]
      }'
  ```

### 🧩 Retrieval Augmented Generation (RAG)

The Retrieval Augmented Generation (RAG) feature allows you to enhance responses by incorporating data from external sources. Below, you will find the methods for managing files and knowledge collections via the API, and how to use them in chat completions effectively.

#### Uploading Files

To utilize external data in RAG responses, you first need to upload the files. The content of the uploaded file is automatically extracted and stored in a vector database.

- **Endpoint**: `POST /api/v1/files/`
- **Curl Example**:

  ```bash
  curl -X POST -H "Authorization: Bearer YOUR_API_KEY" -H "Accept: application/json" \
  -F "file=@/path/to/your/file" http://localhost:3000/api/v1/files/
  ```

- **Python Example**:

  ```python
  import requests
  
  def upload_file(token, file_path):
      url = 'http://localhost:3000/api/v1/files/'
      headers = {
          'Authorization': f'Bearer {token}',
          'Accept': 'application/json'
      }
      files = {'file': open(file_path, 'rb')}
      response = requests.post(url, headers=headers, files=files)
      return response.json()
  ```

#### Adding Files to Knowledge Collections

After uploading, you can group files into a knowledge collection or reference them individually in chats.

- **Endpoint**: `POST /api/v1/knowledge/{id}/file/add`
- **Curl Example**:

  ```bash
  curl -X POST http://localhost:3000/api/v1/knowledge/{knowledge_id}/file/add \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"file_id": "your-file-id-here"}'
  ```

- **Python Example**:

  ```python
  import requests

  def add_file_to_knowledge(token, knowledge_id, file_id):
      url = f'http://localhost:3000/api/v1/knowledge/{knowledge_id}/file/add'
      headers = {
          'Authorization': f'Bearer {token}',
          'Content-Type': 'application/json'
      }
      data = {'file_id': file_id}
      response = requests.post(url, headers=headers, json=data)
      return response.json()
  ```

#### Using Files and Collections in Chat Completions

You can reference both individual files or entire collections in your RAG queries for enriched responses.

##### Using an Individual File in Chat Completions

This method is beneficial when you want to focus the chat model's response on the content of a specific file.

- **Endpoint**: `POST /api/chat/completions`
- **Curl Example**:

  ```bash
  curl -X POST http://localhost:3000/api/chat/completions \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
        "model": "gpt-4-turbo",
        "messages": [
          {"role": "user", "content": "Explain the concepts in this document."}
        ],
        "files": [
          {"type": "file", "id": "your-file-id-here"}
        ]
      }'
  ```

- **Python Example**:

  ```python
  import requests

  def chat_with_file(token, model, query, file_id):
      url = 'http://localhost:3000/api/chat/completions'
      headers = {
          'Authorization': f'Bearer {token}',
          'Content-Type': 'application/json'
      }
      payload = {
          'model': model,
          'messages': [{'role': 'user', 'content': query}],
          'files': [{'type': 'file', 'id': file_id}]
      }
      response = requests.post(url, headers=headers, json=payload)
      return response.json()
  ```

##### Using a Knowledge Collection in Chat Completions

Leverage a knowledge collection to enhance the response when the inquiry may benefit from a broader context or multiple documents.

- **Endpoint**: `POST /api/chat/completions`
- **Curl Example**:

  ```bash
  curl -X POST http://localhost:3000/api/chat/completions \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
        "model": "gpt-4-turbo",
        "messages": [
          {"role": "user", "content": "Provide insights on the historical perspectives covered in the collection."}
        ],
        "files": [
          {"type": "collection", "id": "your-collection-id-here"}
        ]
      }'
  ```

- **Python Example**:

  ```python
  import requests
  
  def chat_with_collection(token, model, query, collection_id):
      url = 'http://localhost:3000/api/chat/completions'
      headers = {
          'Authorization': f'Bearer {token}',
          'Content-Type': 'application/json'
      }
      payload = {
          'model': model,
          'messages': [{'role': 'user', 'content': query}],
          'files': [{'type': 'collection', 'id': collection_id}]
      }
      response = requests.post(url, headers=headers, json=payload)
      return response.json()
  ```

These methods enable effective utilization of external knowledge via uploaded files and curated knowledge collections, enhancing chat applications' capabilities using the Open WebUI API. Whether using files individually or within collections, you can customize the integration based on your specific needs.

## Advantages of Using Open WebUI as a Unified LLM Provider

Open WebUI offers a myriad of benefits, making it an essential tool for developers and businesses alike:

- **Unified Interface**: Simplify your interactions with different LLMs through a single, integrated platform.
- **Ease of Implementation**: Quick start integration with comprehensive documentation and community support.

## Swagger Documentation Links

:::important
Make sure to set the `ENV` environment variable to `dev` in order to access the Swagger documentation for any of these services. Without this configuration, the documentation will not be available.
:::

Access detailed API documentation for different services provided by Open WebUI:

| Application | Documentation Path      |
|-------------|-------------------------|
| Main        | `/docs`                 |


By following these guidelines, you can swiftly integrate and begin utilizing the Open WebUI API. Should you encounter any issues or have questions, feel free to reach out through our Discord Community or consult the FAQs. Happy coding! 🌟


----
Existing codebase
====

{"\/Package.swift":{"swiftFile":{"content":"\/\/ swift-tools-version: 6.0\n\/\/ The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"Promptly\",\n    platforms: [.macOS(.v14)],\n    products: [\n        .executable(name: \"promptly\", targets: [\"Promptly\"]),\n        .library(\n            name: \"PromptlyKit\",\n            targets: [\"PromptlyKit\"]\n        )\n    ],\n    dependencies: [\n        .package(url: \"https:\/\/github.com\/MacPaw\/OpenAI.git\", branch: \"main\"),\n        .package(url: \"https:\/\/github.com\/apple\/swift-argument-parser\", from: \"1.2.0\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"Promptly\",\n            dependencies: [\n                \"PromptlyKit\",\n                .product(name: \"ArgumentParser\", package: \"swift-argument-parser\")\n            ]\n        ),\n        .target(\n            name: \"PromptlyKit\",\n            dependencies: [\n                \"OpenAI\"\n            ]\n        )\n    ],\n    swiftLanguageModes: [.v6]\n)\n","types":{"function":[],"imports":["PackageDescription"]}}},"\/README.md":{"otherFile":{"content":"# Promptly Project\n\nPromptly is a command-line tool that enables you to interact with OpenAI's API securely by storing your API token in your system's Keychain.\n\nThis tool is built using Swift and leverages several dependencies including the [ArgumentParser](https:\/\/github.com\/apple\/swift-argument-parser) for parsing command-line arguments, and [MacPaw\/OpenAI](https:\/\/github.com\/MacPaw\/OpenAI.git) for handling API interactions.\n\n## Features\n\n- **Secure API Token Storage**: Store your OpenAI API token securely in the system's Keychain.\n- **Command-line Interaction**: Pass a context string directly through the command line to interact with OpenAI's API.\n\n## Requirements\n\n- macOS 14 or later\n- Swift 6.0 or later\n- Xcode or Swift Package Manager\n\n## Installation\n\nTo install Promptly, follow these steps:\n\n1. Clone the repository:\n   ```bash\n   git clone https:\/\/github.com\/nicholascross\/Promptly.git\n   cd Promptly\n   ```\n\n2. Build using Swift Package Manager:\n   ```bash\n   swift build -c release\n   ```\n\n3. Copy the executable to your PATH:\n   ```bash\n   cp .build\/release\/Promptly ~\/bin\/promptly\n   ```\n\n## Usage\n\n### Setting Up Your API Token\n\nBefore using the tool to make API requests, you need to store your OpenAI API token. Run the following command and follow the prompts:\n\n```bash\npromptly --setup-token\n```\n\n### Making API Requests\n\nOnce your API token is set up, you can make requests by passing a context string as an argument:\n\n```bash\necho \"some output to send the llm\" | promptly \"Your context about what to do with the input\"\n```\n\n### Help\n\nFor more information on available commands and their usage, use the help option:\n\n```bash\npromptly --help\n```\n\n## Development\n\nTo contribute to Promptly, you can follow these steps:\n\n1. Fork the repository and clone your fork.\n2. Create a new branch for your feature or fix.\n3. Make changes and write tests as necessary.\n4. Push your changes and create a pull request against the main Promptly repository.\n\n## Security\n\nPromptly uses the system's Keychain to securely store the OpenAI API token. Always ensure your system is secure and follow best practices for security.\n\n## License\n\nPromptly is released under the MIT License. See the LICENSE file for more details.\n\n## Acknowledgements\n\nThis project has utilized generative AI tools in various aspects of its development, including coding assistance, testing and documentation enhancement. The use of these tools has contributed to the efficiency and effectiveness of the development process.\n\nThis README was largely generated with promptly.\n\n```bash\ncat Sources\/Promptly\/Promptly.swift | .\/.build\/release\/promptly \"Create a readme for this project\"\n```\n"}},"\/Sources\/Promptly\/Promptly.swift":{"swiftFile":{"content":"import Foundation\nimport ArgumentParser\nimport PromptlyKit\nimport Security\n\n@main\nstruct Promptly: AsyncParsableCommand {\n\n    \/\/\/ Flag to trigger setup mode for storing an API token in the Keychain.\n    @Flag(name: .long, help: \"Run a setup to store your OpenAI API token in the Keychain.\")\n    var setupToken = false\n\n    \/\/\/ The context string passed to the system prompt.\n    @Argument(help: \"A context string to pass to the system prompt.\")\n    var contextArgument: String?\n\n    mutating func run() async throws {\n        let prompter = Prompter()\n\n        if setupToken {\n            try await prompter.setupTokenAction()\n            return\n        }\n\n        guard let contextArgument = contextArgument else {\n            throw ValidationError(\"Usage: promptly <context-string>\\n\")\n        }\n\n        try await prompter.runChat(contextArgument: contextArgument)\n    }\n}\n","types":{"declaredStructs":["Promptly"],"function":[{"name":"run","parameters":[],"parentType":"Promptly"}],"imports":["Foundation","ArgumentParser","PromptlyKit","Security"],"inheritedTypes":["AsyncParsableCommand"]}}},"\/Sources\/PromptlyKit\/Config.swift":{"swiftFile":{"content":"import Foundation\n\nstruct Config: Decodable {\n    let organizationId: String?\n    let host: String?\n    let port: Int?\n\n    init() {\n        organizationId = nil\n        host = nil\n        port = nil\n    }\n\n    static func loadConfig() throws -> Config {\n        let homeDir = FileManager.default.homeDirectoryForCurrentUser\n            let configURL = homeDir.appendingPathComponent(\".config\/promptly\/config.json\")\n\n            do {\n                let data = try Data(contentsOf: configURL)\n                return try JSONDecoder().decode(Config.self, from: data)\n            } catch {\n                return Config()\n            }\n    }\n}\n","types":{"declaredStructs":["Config"],"function":[{"name":"loadConfig","parameters":[],"parentType":"Config","returnType":"Config"}],"imports":["Foundation"],"inheritedTypes":["Decodable"]}}},"\/Sources\/PromptlyKit\/Keychain.swift":{"swiftFile":{"content":"import Foundation\nimport Security\n\npublic struct Keychain {\n    func genericPassword(account: String, service: String) throws -> String? {\n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n                      kSecAttrAccount as String: account,\n                      kSecAttrService as String: service,\n                      kSecMatchLimit as String: kSecMatchLimitOne,\n                      kSecReturnData as String: kCFBooleanTrue as Any,\n                      kSecReturnAttributes as String: kCFBooleanTrue as Any\n        ]\n\n        var item: CFTypeRef?\n        let status = SecItemCopyMatching(query as CFDictionary, &item)\n\n        if status != errSecSuccess && status != errSecItemNotFound {\n            throw KeychainError(status: status)\n        }\n\n        guard let existingItem = item as? [String: Any],\n        let passwordData = existingItem[kSecValueData as String] as? Data,\n        let password = String(data: passwordData, encoding: .utf8)\n        else {\n            return nil\n        }\n\n        return password\n    }\n\n    func setGenericPassword(account: String, service: String, password: String) throws {\n        let passwordData = password.data(using: .utf8)\n\n        let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n                  kSecAttrAccount as String: account,\n                  kSecAttrService as String: service,\n                  kSecReturnAttributes as String: kCFBooleanTrue as Any\n        ]\n\n        var item: CFTypeRef?\n        let status = SecItemCopyMatching(query as CFDictionary, &item)\n\n        if status == errSecSuccess {\n            let updateQuery: [String: Any] = [\n                kSecClass as String: kSecClassGenericPassword,\n                kSecAttrAccount as String: account,\n                kSecAttrService as String: service\n            ]\n\n            let updateAttributes: [String: Any] = [\n                kSecValueData as String: passwordData!\n            ]\n\n            let updateStatus = SecItemUpdate(updateQuery as CFDictionary, updateAttributes as CFDictionary)\n            if updateStatus != errSecSuccess {\n                throw KeychainError(status: updateStatus)\n            }\n        } else if status == errSecItemNotFound {\n            let newItem: [String: Any] = [\n                kSecClass as String: kSecClassGenericPassword,\n                kSecAttrAccount as String: account,\n                kSecAttrService as String: service,\n                kSecValueData as String: passwordData!\n            ]\n\n            let addStatus = SecItemAdd(newItem as CFDictionary, nil)\n            if addStatus != errSecSuccess {\n                throw KeychainError(status: addStatus)\n            }\n        } else {\n            throw KeychainError(status: status)\n        }\n    }\n}\n","types":{"declaredStructs":["Keychain"],"function":[{"name":"genericPassword","parameters":[{"name":"account","type":"String"},{"name":"service","type":"String"}],"parentType":"Keychain","returnType":"String?"},{"name":"setGenericPassword","parameters":[{"name":"account","type":"String"},{"name":"service","type":"String"},{"name":"password","type":"String"}],"parentType":"Keychain"}],"imports":["Foundation","Security"]}}},"\/Sources\/PromptlyKit\/KeychainError.swift":{"swiftFile":{"content":"import Foundation\n\nenum KeychainError: Error {\n    case success\n    case unimplemented\n    case diskFull\n    case ioError\n    case invalidParameter\n    case writePermissionError\n    case allocateFailure\n    case userCanceled\n    case badRequest\n    case internalComponent\n    case coreFoundationUnknown\n    case notAvailable\n    case readOnly\n    case authFailed\n    case noSuchKeychain\n    case invalidKeychain\n    case duplicateKeychain\n    case duplicateCallback\n    case invalidCallback\n    case duplicateItem\n    case itemNotFound\n    case bufferTooSmall\n    case dataTooLarge\n    case noSuchAttr\n    case invalidItemRef\n    case invalidSearchRef\n    case noSuchClass\n    case noDefaultKeychain\n    case interactionNotAllowed\n    case readOnlyAttr\n    case wrongSecVersion\n    case keySizeNotAllowed\n    case noStorageModule\n    case noCertificateModule\n    case noPolicyModule\n    case interactionRequired\n    case dataNotAvailable\n    case dataNotModifiable\n    case createChainFailed\n    case aclNotSimple\n    case policyNotFound\n    case invalidTrustSetting\n    case noAccessForItem\n    case invalidOwnerEdit\n    case trustNotAvailable\n    case unsupportedFormat\n    case unknownFormat\n    case keyIsSensitive\n    case multiplePrivKeys\n    case passphraseRequired\n    case invalidPasswordRef\n    case invalidTrustSettings\n    case noTrustSettings\n    case pkcs12VerifyFailure\n    case decodeError\n    case unknownError(OSStatus)\n\n    \/\/ swiftlint:disable cyclomatic_complexity\n    \/\/ swiftlint:disable:next function_body_length\n    init(status: OSStatus) {\n        switch status {\n        case errSecSuccess: self = .success\n        case errSecUnimplemented: self = .unimplemented\n        case errSecDiskFull: self = .diskFull\n        case errSecIO: self = .ioError\n        case errSecParam: self = .invalidParameter\n        case errSecWrPerm: self = .writePermissionError\n        case errSecAllocate: self = .allocateFailure\n        case errSecUserCanceled: self = .userCanceled\n        case errSecBadReq: self = .badRequest\n        case errSecInternalComponent: self = .internalComponent\n        case errSecCoreFoundationUnknown: self = .coreFoundationUnknown\n        case errSecNotAvailable: self = .notAvailable\n        case errSecReadOnly: self = .readOnly\n        case errSecAuthFailed: self = .authFailed\n        case errSecNoSuchKeychain: self = .noSuchKeychain\n        case errSecInvalidKeychain: self = .invalidKeychain\n        case errSecDuplicateKeychain: self = .duplicateKeychain\n        case errSecDuplicateCallback: self = .duplicateCallback\n        case errSecInvalidCallback: self = .invalidCallback\n        case errSecDuplicateItem: self = .duplicateItem\n        case errSecItemNotFound: self = .itemNotFound\n        case errSecBufferTooSmall: self = .bufferTooSmall\n        case errSecDataTooLarge: self = .dataTooLarge\n        case errSecNoSuchAttr: self = .noSuchAttr\n        case errSecInvalidItemRef: self = .invalidItemRef\n        case errSecInvalidSearchRef: self = .invalidSearchRef\n        case errSecNoSuchClass: self = .noSuchClass\n        case errSecNoDefaultKeychain: self = .noDefaultKeychain\n        case errSecInteractionNotAllowed: self = .interactionNotAllowed\n        case errSecReadOnlyAttr: self = .readOnlyAttr\n        case errSecWrongSecVersion: self = .wrongSecVersion\n        case errSecKeySizeNotAllowed: self = .keySizeNotAllowed\n        case errSecNoStorageModule: self = .noStorageModule\n        case errSecNoCertificateModule: self = .noCertificateModule\n        case errSecNoPolicyModule: self = .noPolicyModule\n        case errSecInteractionRequired: self = .interactionRequired\n        case errSecDataNotAvailable: self = .dataNotAvailable\n        case errSecDataNotModifiable: self = .dataNotModifiable\n        case errSecCreateChainFailed: self = .createChainFailed\n        case errSecACLNotSimple: self = .aclNotSimple\n        case errSecPolicyNotFound: self = .policyNotFound\n        case errSecInvalidTrustSetting: self = .invalidTrustSetting\n        case errSecNoAccessForItem: self = .noAccessForItem\n        case errSecInvalidOwnerEdit: self = .invalidOwnerEdit\n        case errSecTrustNotAvailable: self = .trustNotAvailable\n        case errSecUnsupportedFormat: self = .unsupportedFormat\n        case errSecUnknownFormat: self = .unknownFormat\n        case errSecKeyIsSensitive: self = .keyIsSensitive\n        case errSecMultiplePrivKeys: self = .multiplePrivKeys\n        case errSecPassphraseRequired: self = .passphraseRequired\n        case errSecInvalidPasswordRef: self = .invalidPasswordRef\n        case errSecInvalidTrustSettings: self = .invalidTrustSettings\n        case errSecNoTrustSettings: self = .noTrustSettings\n        case errSecPkcs12VerifyFailure: self = .pkcs12VerifyFailure\n        case errSecDecode: self = .decodeError\n        default: self = .unknownError(status)\n        }\n    }\n}\n\/\/ swiftlint:enable cyclomatic_complexity\n","types":{"declaredEnums":["KeychainError"],"function":[],"imports":["Foundation"],"inheritedTypes":["Error"]}}},"\/Sources\/PromptlyKit\/Prompter.swift":{"swiftFile":{"content":"import Foundation\nimport OpenAI\n\npublic struct Prompter {\n\n    public init() {}\n\n    \/\/\/ Prompts the user for a token and stores it in the Keychain.\n    public func setupTokenAction() async throws {\n        print(\"Enter your OpenAI API token: \", terminator: \"\")\n        guard let token = readLine(strippingNewline: true), !token.isEmpty else {\n            print(\"Token cannot be empty.\")\n            return\n        }\n\n        do {\n            try Keychain().setGenericPassword(account: \"openai_token\", service: \"Promptly\", password: token)\n            print(\"Token stored in Keychain successfully!\")\n        } catch {\n            print(\"Failed to store token: \\(error.localizedDescription)\")\n        }\n    }\n\n    \/\/\/ Handles reading user input from stdin, loading configuration, retrieving the token,\n    \/\/\/ and sending a query to OpenAI, then prints the result.\n    public func runChat(contextArgument: String) async throws {\n        let inputData = FileHandle.standardInput.readDataToEndOfFile()\n        let userInput = String(data: inputData, encoding: .utf8) ?? \"\"\n\n        let config = try Config.loadConfig()\n\n        guard let token = try Keychain().genericPassword(\n            account: \"openai_token\",\n            service: \"Promptly\"\n        ) else {\n            throw PrompterError.tokenNotSpecified\n        }\n\n        let openAIConfig = OpenAI.Configuration(\n            token: token,\n            organizationIdentifier: config.organizationId,\n            host: config.host ?? \"api.openai.com\",\n            port: config.port ?? 443,\n            timeoutInterval: 60.0\n        )\n        let openAI = OpenAI(configuration: openAIConfig)\n\n        let query = ChatQuery(\n            messages: [\n                .system(.init(content: contextArgument)),\n                .user(.init(content: .string(userInput)))\n            ],\n            model: .gpt4_turbo,\n            maxTokens: 500,\n            temperature: 0.7\n        )\n\n        for try await result in openAI.chatsStream(query: query) {\n            if let firstChoice = result.choices.first,\n               let content = firstChoice.delta.content {\n                    print(content, terminator: \"\")\n            }\n        }\n    }\n}\n","types":{"declaredStructs":["Prompter"],"function":[{"name":"setupTokenAction","parameters":[],"parentType":"Prompter"},{"name":"runChat","parameters":[{"name":"contextArgument","type":"String"}],"parentType":"Prompter"}],"imports":["Foundation","OpenAI"]}}},"\/Sources\/PromptlyKit\/PrompterError.swift":{"swiftFile":{"content":"public enum PrompterError: Error {\n    case tokenNotSpecified\n}\n","types":{"declaredEnums":["PrompterError"],"function":[],"imports":[],"inheritedTypes":["Error"]}}}}
